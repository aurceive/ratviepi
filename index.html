<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Выбор случайных пользователей Twitch</title>
    <style>
      :root {
        --bg: #0b0e12;
        --card: #0f1418;
        --muted: #8b98a4;
        --accent: #9146ff;
        --glass: rgba(255, 255, 255, 0.03);
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        padding: 20px;
        display: flex;
        align-items: flex-start;
        justify-content: center;
        min-height: 100vh;
        background: linear-gradient(180deg, #040608 0%, #0b0f14 100%);
        color: #e6eef6;
        font-family: Inter, Segoe UI, Roboto, Arial;
      }

      .wrap {
        width: 1100px;
        max-width: 98vw;
        background: var(--card);
        border-radius: 12px;
        padding: 18px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
        display: flex;
        gap: 16px;
      }

      .col {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .left {
        flex: 2;
        min-width: 500px;
      }

      .right {
        flex: 1;
        min-width: 400px;
        max-width: 800px;
      }

      h1 {
        font-size: 16px;
        margin: 0 0 6px 0;
      }

      label {
        font-size: 12px;
        color: var(--muted);
      }

      input[type="text"],
      input[type="number"],
      select {
        width: 100%;
        box-sizing: border-box;
        padding: 8px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.04);
        background: var(--glass);
        color: inherit;
      }

      .row {
        display: flex;
        gap: 8px;
      }

      button {
        background: var(--accent);
        border: none;
        color: white;
        padding: 8px 10px;
        border-radius: 8px;
        cursor: pointer;
      }

      .ghost {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.06);
        color: var(--muted);
      }

      .small {
        padding: 6px 8px;
        font-size: 13px;
      }

      .seg {
        display: flex;
        background: rgba(255, 255, 255, 0.02);
        border-radius: 8px;
        padding: 4px;
      }

      .seg button {
        flex: 1;
        background: transparent;
        border: none;
        color: var(--muted);
        padding: 8px;
        border-radius: 6px;
      }

      .seg button.active {
        background: rgba(255, 255, 255, 0.04);
        color: white;
      }

      .panel {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          transparent
        );
        padding: 12px;
        border-radius: 10px;
      }

      .stat {
        font-size: 14px;
      }

      #results {
        min-height: 80px;
        background: rgba(0, 0, 0, 0.1);
        padding: 8px;
        border-radius: 8px;
        overflow: auto;
      }

      .winner {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.02);
      }

      .badge {
        background: rgba(255, 255, 255, 0.03);
        padding: 4px 8px;
        border-radius: 8px;
        color: var(--muted);
      }

      .ts {
        font-size: 11px;
        color: var(--muted);
      }

      .chat-holder {
        height: 640px;
        border-radius: 8px;
        overflow: hidden;
        background: #000;
      }
      .chat-list {
        padding:0px;
        height: calc(100% + 15px);
        overflow: hidden; /* no scrollbar — extra content is clipped */
        box-sizing: border-box;
      }
      .chat-msg{
        display:flex;
        gap:8px;
        align-items:flex-start;
        padding:6px 4px;
        border-bottom:1px solid rgba(255, 255, 255, 0.02);
        font-size:13px;
        box-sizing: border-box;
      }
      .chat-user{
        font-weight:600;
        margin-right:6px;
        width:120px;
        flex: 0 0 120px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .chat-text{
        display:inline-block;
        max-width: calc(100% - 140px);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .controls-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      .footer-note {
        font-size: 12px;
        color: var(--muted);
      }

      /* modal */
      .modal {
        position: fixed;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.6);
      }

      .modal .card {
        width: 520px;
        max-width: 94vw;
        background: var(--card);
        padding: 12px;
        border-radius: 8px;
      }

      .msg {
        font-size: 13px;
        padding: 6px;
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.02);
        margin-bottom: 6px;
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <div class="col left">
        <h1>Twitch Random Picker</h1>
        <div class="panel">
          <label>Название канала (id)</label>
          <div class="row">
            <input id="channel" type="text" placeholder="channel_name" /><button
              id="connect"
              class="small"
            >
              Подключиться
            </button>
          </div>
        </div>

        <div class="panel">
          <label>Хранилище сообщений</label>
          <div class="row">
            <button id="clearAll" class="ghost small">Очистить всё</button>
            <button id="clearOld" class="ghost small">Очистить ≥1 час</button>
          </div>
          <div style="margin-top: 8px" class="row">
            <div class="stat">Сообщений: <b id="msgCount">0</b></div>
            <div class="stat">Размер: <b id="msgSize">0 B</b></div>
          </div>
        </div>

        <div class="panel">
          <label>Время учёта сообщений</label>
          <div class="row">
            <input id="timeWindow" type="number" min="0" value="0" />
            <div class="ts">минут (0 = без ограничений)</div>
          </div>
          <label style="margin-top: 8px"
            >Количество выбираемых пользователей</label
          >
          <input id="pickCount" type="number" min="1" value="3" />
        </div>

        <div class="panel">
          <label>Фильтр регистрации</label>
          <div class="seg" id="filterMode">
            <button data-mode="exact">Точное</button>
            <button data-mode="contains" class="active">Содержит</button>
            <button data-mode="regex">Регэксп</button>
          </div>
          <div style="margin-top: 8px">
            <input
              id="filterText"
              type="text"
              placeholder="Текст или регулярное выражение"
            />
          </div>
        </div>

        <div class="panel">
          <label>Зарегистрированные</label>
          <div class="row">
            <div class="stat">Всего: <b id="registeredCount">0</b></div>
          </div>
          <div style="margin-top: 8px" class="row" style="justify-content:space-between;align-items:center;">
            <button id="pick" class="small">Результат</button>
            <button id="pickFirst" class="small ghost">Первые</button>
            <div style="flex:1"></div>
            <button id="clearWinners" class="small ghost">Очистить</button>
            <button id="exportWinners" class="small ghost">Экспорт</button>
            <button id="showHistory" class="small ghost">История</button>
          </div>
          <div id="results" style="margin-top: 8px;"></div>
        </div>
      </div>

      <div class="col right">
        <h1>Чат канала</h1>
        <div class="chat-holder panel" id="chatArea">
          <!-- custom compact chat (only user messages) -->
          <div id="customChat" class="chat-list"></div>
          <!-- embed removed -->
        </div>
        <div style="margin-top: 12px" class="panel row">
          <div class="footer-note">
            Подключение: <span id="status">offline</span>
          </div>
        </div>
      </div>
    </div>

    <div class="modal" id="modal">
      <div class="card">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
          "
        >
          <b id="modalTitle">Сообщения</b>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="clearHistory" class="small ghost" style="display:none">Очистить историю</button>
            <button id="modalClose">Закрыть</button>
          </div>
        </div>
        <div id="modalContent" style="max-height: 60vh; overflow: auto"></div>
      </div>
    </div>

    <!-- Подключение tmi.js: основной CDN (jsDelivr) + модульный fallback (skypack/esm.sh) -->
    <script src="https://cdn.jsdelivr.net/npm/tmi.js/dist/tmi.min.js"></script>
    <script type="module">
      // Если по какой-то причине глобальный `tmi` не загружен (CDN блокируется),
      // пробуем динамически импортировать версию для ESM из Skypack или esm.sh.
      if (typeof window.tmi === "undefined") {
        (async () => {
          try {
            const m = await import("https://cdn.skypack.dev/tmi.js");
            window.tmi = m.default || m;
            console.info("tmi.js loaded from skypack");
          } catch (e) {
            try {
              const m2 = await import("https://esm.sh/tmi.js");
              window.tmi = m2.default || m2;
              console.info("tmi.js loaded from esm.sh");
            } catch (err) {
              console.warn("Не удалось загрузить tmi.js из CDN fallback:", err);
            }
          }
        })();
      }
    </script>
    <!-- SheetJS for XLSX export -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <script>
      // Простая SPA логика
      const STORAGE_KEY = "rv_messages_v1";
      const SETTINGS_KEY = "rv_settings_v1";
      const WINNERS_KEY = "rv_winners_v1";
      const channelInput = document.getElementById("channel");
      const connectBtn = document.getElementById("connect");
      const statusEl = document.getElementById("status");
      const msgCountEl = document.getElementById("msgCount");
      const msgSizeEl = document.getElementById("msgSize");
      const clearAllBtn = document.getElementById("clearAll");
      const clearOldBtn = document.getElementById("clearOld");
      const timeWindowInput = document.getElementById("timeWindow");
      const filterText = document.getElementById("filterText");
      const filterModeEl = document.getElementById("filterMode");
      const registeredCountEl = document.getElementById("registeredCount");
      const resultsEl = document.getElementById("results");
      const pickFirstBtn = document.getElementById("pickFirst");
      const pickBtn = document.getElementById("pick");
      const showHistoryBtn = document.getElementById("showHistory");
      const clearHistoryBtn = document.getElementById('clearHistory');
      const exportWinnersBtn = document.getElementById('exportWinners');
      const clearWinnersBtn = document.getElementById('clearWinners');
      const pickCountInput = document.getElementById("pickCount");
      const modal = document.getElementById("modal");
      const modalContent = document.getElementById("modalContent");
      const modalTitle = document.getElementById("modalTitle");
      const modalClose = document.getElementById("modalClose");
      const customChatEl = document.getElementById('customChat');

      let client = null;
      let connectedChannel = null;
      let filterMode = "contains";
      let settings = { filterTexts: { exact: '', contains: '', regex: '' } };
      // Background update / throttle state
      let lastRegisteredUpdate = 0; // timestamp of last actual update
      let bgInactivityTimer = null; // fires after 1s of inactivity and will call update (initiator 'timer')
      let throttleTimer = null; // ensures updates not more frequent than THROTTLE_MS
      const THROTTLE_MS = 100; // 0.1s min interval between actual updates
      const BG_MS = 1000; // 1s background interval

      // load messages
      function loadMessages() {
        try {
          const s = localStorage.getItem(STORAGE_KEY);
          return s ? JSON.parse(s) : [];
        } catch (e) {
          return [];
        }
      }
      function saveMessages(arr) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(arr));
        updateStats();
      }
      function pushMessage(msg) {
        const arr = loadMessages();
        arr.push(msg);
        saveMessages(arr);
      }
      function updateStats() {
        const arr = loadMessages();
        msgCountEl.textContent = arr.length;
        msgSizeEl.textContent = prettyBytes(
          new Blob([JSON.stringify(arr)]).size
        );
      }
      function prettyBytes(n) {
        if (n < 1024) return n + " B";
        if (n < 1024 * 1024) return (n / 1024).toFixed(1) + " KB";
        return (n / (1024 * 1024)).toFixed(2) + " MB";
      }

      clearAllBtn.addEventListener("click", () => {
        saveMessages([]);
        renderRegistered();
      });
      clearOldBtn.addEventListener("click", () => {
        const cutoff = Date.now() - 3600 * 1000;
        const arr = loadMessages().filter((m) => m.t >= cutoff);
        saveMessages(arr);
        renderRegistered();
      });

      function updateFilterPlaceholder(mode){
        if(!mode) mode = filterMode;
        if(mode === 'exact') filterText.placeholder = 'Точное сообщение (ровно как указано)';
        else if(mode === 'contains') filterText.placeholder = 'Фрагмент текста, который должен содержаться';
        else if(mode === 'regex') filterText.placeholder = 'Регулярное выражение (JS)';
      }

      // filter mode UI
      filterModeEl.querySelectorAll("button").forEach((b) => {
        b.addEventListener("click", () => {
          filterModeEl
            .querySelectorAll("button")
            .forEach((x) => x.classList.remove("active"));
          b.classList.add("active");
          // store current input into settings for previous mode
          if(settings && settings.filterTexts) settings.filterTexts[filterMode] = filterText.value || '';
          filterMode = b.dataset.mode;
          // load filter text for this mode
          filterText.value = (settings && settings.filterTexts && settings.filterTexts[filterMode]) ? settings.filterTexts[filterMode] : '';
          // update placeholder
          updateFilterPlaceholder(filterMode);
          saveSettings();
          renderRegistered();
        });
      });

      // recompute on changes (updates counts) + save settings
      [filterText, timeWindowInput, pickCountInput].forEach((el) =>
        el.addEventListener("input", () => {
          // save filter per current mode
          if(el === filterText){ if(!settings.filterTexts) settings.filterTexts = { exact:'', contains:'', regex:'' }; settings.filterTexts[filterMode] = filterText.value || ''; }
          saveSettings();
          renderRegistered();
        })
      );
      channelInput.addEventListener("input", () => {
        saveSettings();
      });

      // settings persistence
      function saveSettings() {
        try {
          // merge current settings values
          const obj = Object.assign({}, settings || {});
          obj.channel = channelInput.value || '';
          obj.timeWindow = timeWindowInput.value || '0';
          obj.pickCount = pickCountInput.value || '1';
          obj.filterMode = filterMode || 'contains';
          if(!obj.filterTexts) obj.filterTexts = { exact:'', contains:'', regex:'' };
          // ensure current filterText stored
          obj.filterTexts[filterMode] = filterText.value || '';
          settings = obj;
          localStorage.setItem(SETTINGS_KEY, JSON.stringify(obj));
        } catch (e) {
          console.warn("Не удалось сохранить настройки", e);
        }
      }

      function loadSettings() {
        try {
          const s = localStorage.getItem(SETTINGS_KEY);
          if (!s) return;
          const obj = JSON.parse(s) || {};
          settings = obj;
          if (obj.channel) channelInput.value = obj.channel;
          if (obj.timeWindow !== undefined) timeWindowInput.value = obj.timeWindow;
          if (obj.pickCount !== undefined) pickCountInput.value = obj.pickCount;
          if (!obj.filterTexts) obj.filterTexts = { exact:'', contains:'', regex:'' };
          // restore mode
          if (obj.filterMode) filterMode = obj.filterMode;
          filterModeEl.querySelectorAll("button").forEach((x) => x.classList.remove("active"));
          const btn = filterModeEl.querySelector(`button[data-mode='${filterMode}']`);
          if (btn) btn.classList.add("active");
          // set filter text for current mode
          filterText.value = (obj.filterTexts && obj.filterTexts[filterMode]) ? obj.filterTexts[filterMode] : '';
          // update placeholder
          updateFilterPlaceholder(filterMode);
          // try to auto-connect when channel present and tmi becomes available
          if (channelInput.value && channelInput.value.trim()) {
            tryAutoConnect(channelInput.value.trim());
          }
        } catch (e) {
          console.warn("Не удалось загрузить настройки", e);
        }
      }

      // Try to connect when tmi is ready. Polls until window.tmi exists or timeout.
      function tryAutoConnect(ch, attempt = 0) {
        if (!ch) return;
        if (window.tmi) {
          try { connectBtn.click(); } catch (e) { console.warn('Auto-connect failed', e); }
          return;
        }
        if (attempt > 30) { console.warn('Auto-connect: tmi not available'); return; }
        setTimeout(()=> tryAutoConnect(ch, attempt+1), 300);
      }

      // pick results
      pickBtn.addEventListener("click", () => {
        const regs = computeRegistered(false);
        const n = Math.max(
          1,
          Math.min(parseInt(pickCountInput.value || 1), regs.length)
        );
        if (regs.length === 0) {
          showInfoModal('Нет зарегистрированных пользователей');
          return;
        }
        const winners = pickN(regs, n);
        showWinners(winners);
      });

      pickFirstBtn.addEventListener("click", () => {
        const regs = computeRegistered(true);
        const n = Math.max(
          1,
          Math.min(parseInt(pickCountInput.value || 1), regs.length)
        );
        if (regs.length === 0) {
          showInfoModal('Нет зарегистрированных пользователей');
          return;
        }
        const winners = regs.slice(0, n);
        showWinners(winners);
      });

      showHistoryBtn.addEventListener("click", () => {
        showWinnersHistoryModal();
      });

      // Read currently displayed winners from DOM
      function getDisplayedWinners() {
        const out = [];
        if (!resultsEl) return out;
        const nodes = resultsEl.querySelectorAll('.winner');
        nodes.forEach((n) => {
          const left = n.querySelector('div');
          const b = left ? left.querySelector('b') : null;
          const user = b ? b.textContent.replace(/^@/, '') : '';
          const tsEl = left ? left.querySelector('.ts') : null;
          let tText = '';
          let msg = '';
          if (tsEl) {
            const parts = tsEl.textContent.split(' — ');
            tText = parts[0] ? parts[0].trim() : '';
            msg = parts[1] ? parts.slice(1).join(' — ').trim() : '';
          }
          out.push({ user, t: tText, msg });
        });
        return out;
      }

      // Clear winners area
      if (clearWinnersBtn) {
        clearWinnersBtn.addEventListener('click', () => {
          resultsEl.innerHTML = '';
        });
      }

      // Export button: open modal with export options
      if (exportWinnersBtn) {
        exportWinnersBtn.addEventListener('click', () => {
          const winners = getDisplayedWinners();
          if (!winners.length) {
            showInfoModal('Нет победителей для экспорта');
            return;
          }
          modalTitle.textContent = 'Экспорт победителей';
          try { clearHistoryBtn.style.display = 'none'; } catch (e) {}
          modalContent.innerHTML = `
            <div style="display:flex;flex-direction:column;gap:8px">
              <div class="msg">Победители: <b>${winners.length}</b></div>
              <div style="display:flex;gap:8px">
                <button id="doExportXlsx" class="small">Экспорт в xlsx</button>
                <button id="doCopyLogins" class="small ghost">Копировать логины</button>
              </div>
            </div>`;
          modal.style.display = 'flex';
          // attach handlers
          setTimeout(()=>{
            const btnX = document.getElementById('doExportXlsx');
            const btnC = document.getElementById('doCopyLogins');
            if(btnX) btnX.addEventListener('click', ()=>{
              exportDisplayedToXlsx(winners);
            });
            if(btnC) btnC.addEventListener('click', ()=>{
              copyDisplayedLogins(winners);
            });
          },0);
        });
      }

      function exportDisplayedToXlsx(winners){
        const rows = winners.map((w) => ({ User: w.user, Timestamp: w.t, Message: w.msg }));
        try{
          const ws = XLSX.utils.json_to_sheet(rows);
          const wb = XLSX.utils.book_new();
          XLSX.utils.book_append_sheet(wb, ws, 'Winners');
          const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
          const blob = new Blob([wbout], { type: 'application/octet-stream' });
          const filename = `winners_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.xlsx`;
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
        }catch(e){ console.warn('Export failed', e); showInfoModal('Ошибка при экспорте: ' + (e && e.message ? e.message : e)); }
      }

      function copyDisplayedLogins(winners){
        const logins = winners.map(w => (w.user || '').replace(/^@/,'')).join(' ');
        if(!logins){ showInfoModal('Нет логинов для копирования'); return; }
        if(navigator.clipboard && navigator.clipboard.writeText){
          navigator.clipboard.writeText(logins).then(()=> showInfoModal('Логины скопированы в буфер обмена'))
            .catch(()=> fallbackCopy(logins));
        } else {
          fallbackCopy(logins);
        }
      }

      function fallbackCopy(text){
        try{
          const ta = document.createElement('textarea'); ta.value = text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); showInfoModal('Логины скопированы в буфер обмена');
        }catch(e){ showInfoModal('Не удалось скопировать логины'); }
      }

      // clear history button (in modal header)
      clearHistoryBtn.addEventListener('click', ()=>{
        if(!confirm('Очистить историю победителей?')) return;
        try{ localStorage.removeItem(WINNERS_KEY); modalContent.innerHTML = '<div class="msg">История пуста</div>'; }catch(e){ console.warn(e); }
      });

      // close modal when clicking outside card
      modal.addEventListener('click', (e)=>{ if(e.target === modal) modal.style.display = 'none'; });

      function pickN(arr, n) {
        const copy = arr.slice();
        const out = [];
        for (let i = 0; i < n && copy.length; i++) {
          const idx = Math.floor(Math.random() * copy.length);
          out.push(copy.splice(idx, 1)[0]);
        }
        return out;
      }

      function showWinners(winners) {
        resultsEl.innerHTML = "";
        winners.forEach((w) => {
          const div = document.createElement("div");
          div.className = "winner";
          const left = document.createElement("div");
          left.innerHTML = `<b>@${escapeHtml(
            w.user
          )}</b><div class='ts'>${new Date(
            w.t
          ).toLocaleString()} — ${escapeHtml(w.msg)}</div>`;
          const right = document.createElement("div");
          right.innerHTML = `<button class='small ghost' data-user='${escapeHtml(
            w.user
          )}'>Все сообщения</button>`;
          div.appendChild(left);
          div.appendChild(right);
          resultsEl.appendChild(div);
          right.querySelector("button").addEventListener("click", () => {
            openUserModal(w.user);
          });
        });
        // save winners to history (timestamp + snapshot of winners)
        try {
          addWinnersToHistory(
            winners.map((x) => ({ user: x.user, msg: x.msg, t: x.t }))
          );
        } catch (e) {
          console.warn("Не удалось сохранить историю победителей", e);
        }
      }

      // Winners history storage (keep last 100 draws)
      function loadWinnersHistory() {
        try {
          const s = localStorage.getItem(WINNERS_KEY);
          return s ? JSON.parse(s) : [];
        } catch (e) {
          return [];
        }
      }
      function saveWinnersHistory(arr) {
        try {
          localStorage.setItem(WINNERS_KEY, JSON.stringify(arr));
        } catch (e) {
          console.warn("Не удалось сохранить историю", e);
        }
      }
      function addWinnersToHistory(winners) {
        const hist = loadWinnersHistory();
        hist.unshift({ t: Date.now(), winners });
        if (hist.length > 100) hist.length = 100;
        saveWinnersHistory(hist);
      }

      // History UI: show modal with last draws
      function showWinnersHistoryModal() {
        const hist = loadWinnersHistory();
        modalTitle.textContent = "История розыгрышей";
        // Показать кнопку очистки истории только для истории
        try { clearHistoryBtn.style.display = ''; } catch(e){}
        if (!hist.length) {
          modalContent.innerHTML = '<div class="msg">История пуста</div>';
          modal.style.display = "flex";
          return;
        }
        // hint about storage limit
        const hint = '<div class="msg" style="font-size:12px;color:var(--muted)">Сохранены последние 100 розыгрышей.</div>';
        modalContent.innerHTML = hint + hist
          .map((h, idx) => {
            const when = new Date(h.t).toLocaleString();
            const list = h.winners
              .map(
                (w) =>
                  `<div style="margin-bottom:6px"><b>@${escapeHtml(
                    w.user
                  )}</b> <span class='ts'>${new Date(
                    w.t
                  ).toLocaleString()}</span><div>${escapeHtml(
                    w.msg
                  )}</div></div>`
              )
              .join("");
            // Кнопка восстановить справа в заголовке блока
            return `<div class='msg' style="position:relative;"><div style="font-weight:600;display:flex;align-items:center;justify-content:space-between;"><span>${when}</span><button class='small ghost restore-history-btn' data-idx='${idx}' style="margin-left:8px;">Восстановить</button></div>${list}</div>`;
          })
          .join("");
        // Навесить обработчики на кнопки восстановления
        setTimeout(()=>{
          const btns = modalContent.querySelectorAll('.restore-history-btn');
          btns.forEach(btn=>{
            btn.addEventListener('click', function(){
              const idx = parseInt(this.getAttribute('data-idx'));
              if (!isNaN(idx) && hist[idx] && hist[idx].winners) {
                // Заменить область победителей
                resultsEl.innerHTML = '';
                hist[idx].winners.forEach((w) => {
                  const div = document.createElement("div");
                  div.className = "winner";
                  const left = document.createElement("div");
                  left.innerHTML = `<b>@${escapeHtml(
                    w.user
                  )}</b><div class='ts'>${new Date(
                    w.t
                  ).toLocaleString()} — ${escapeHtml(w.msg)}</div>`;
                  const right = document.createElement("div");
                  right.innerHTML = `<button class='small ghost' data-user='${escapeHtml(
                    w.user
                  )}'>Все сообщения</button>`;
                  div.appendChild(left);
                  div.appendChild(right);
                  resultsEl.appendChild(div);
                  right.querySelector("button").addEventListener("click", () => {
                    openUserModal(w.user);
                  });
                });
                // Закрыть модальное окно
                modal.style.display = 'none';
              }
            });
          });
        }, 0);
        modal.style.display = "flex";
      }

      // Simple info modal helper
      function showInfoModal(message, title = 'Информация'){
        modalTitle.textContent = title;
        modalContent.innerHTML = `<div class="msg">${escapeHtml(message)}</div>`;
        // hide clearHistory in info/modal context unless it's history view
        try{ clearHistoryBtn.style.display = 'none'; }catch(e){}
        modal.style.display = 'flex';
      }

      function openUserModal(user) {
        const all = loadMessages()
          .filter((m) => m.user.toLowerCase() === user.toLowerCase())
          .sort((a, b) => b.t - a.t);
        modalTitle.textContent = "Сообщения @" + user;
        // Скрыть кнопку очистки истории для модального окна сообщений пользователя
        try { clearHistoryBtn.style.display = 'none'; } catch(e){}
        modalContent.innerHTML = all
          .map(
            (m) =>
              `<div class='msg'><div style="font-weight:600">${escapeHtml(
                m.user
              )} <span class='ts'>${new Date(
                m.t
              ).toLocaleString()}</span></div><div>${escapeHtml(
                m.msg
              )}</div></div>`
          )
          .join("");
        modal.style.display = "flex";
      }
      modalClose.addEventListener(
        "click",
        () => (modal.style.display = "none")
      );

      function escapeHtml(s) {
        return (s + "").replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }

      // Compute deterministic color for nicknames
      function getNickColor(name) {
        const palette = [
          '#e06c75','#e5c07b','#98c379','#56b6c2','#61afef','#c678dd','#d19a66','#7fdbca','#ffb86b','#89ddff'
        ];
        let h = 0;
        for (let i = 0; i < name.length; i++) {
          h = (h << 5) - h + name.charCodeAt(i);
          h |= 0;
        }
        return palette[Math.abs(h) % palette.length];
      }

      // Custom compact chat renderer (shows only user messages from local store)
      // It appends recent messages and then trims oldest messages so that
      // total content height does not exceed the visible container (no scrollbar).
      function renderCustomChat(limit = 200) {
        if (!customChatEl) return;
        const all = loadMessages();
        const msgs = all.slice(-limit); // oldest -> newest
        customChatEl.innerHTML = '';
        for (let i = 0; i < msgs.length; i++) {
          const m = msgs[i];
          const div = document.createElement('div');
          div.className = 'chat-msg';

          const userSpan = document.createElement('span');
          userSpan.className = 'chat-user';
          userSpan.textContent = m.user;
          userSpan.style.color = getNickColor(m.user || '');

          const textSpan = document.createElement('span');
          textSpan.className = 'chat-text';
          textSpan.textContent = m.msg;

          const tsDiv = document.createElement('div');
          tsDiv.className = 'ts';
          tsDiv.style.opacity = '0.6';
          tsDiv.style.fontSize = '11px';
          tsDiv.style.marginTop = '4px';
          tsDiv.textContent = new Date(m.t).toLocaleTimeString();

          div.appendChild(userSpan);
          div.appendChild(textSpan);
          div.appendChild(tsDiv);

          customChatEl.appendChild(div);
        }

        // Trim oldest messages while content height exceeds viewport
        while (
          customChatEl.firstChild &&
          customChatEl.scrollHeight > customChatEl.clientHeight
        ) {
          customChatEl.removeChild(customChatEl.firstChild);
        }
      }

      function computeRegistered(preferEarliest = false) {
        const arr = loadMessages();
        const tw = Math.max(0, parseInt(timeWindowInput.value || 0));
        const cutoff = tw ? Date.now() - tw * 60 * 1000 : 0;
        const ft = (filterText.value || "").trim();
        const mode = filterMode;
        const byUser = new Map();
        if (preferEarliest) {
          // iterate from oldest to newest, keep first occurrence
          for (let i = 0; i < arr.length; i++) {
            const m = arr[i];
            if (cutoff && m.t < cutoff) continue;
            if (!matchesFilter(m.msg, ft, mode)) continue;
            const key = m.user.toLowerCase();
            if (!byUser.has(key))
              byUser.set(key, { user: m.user, msg: m.msg, t: m.t });
          }
        } else {
          // default: prefer latest (iterate from newest to oldest)
          for (let i = arr.length - 1; i >= 0; i--) {
            const m = arr[i];
            if (cutoff && m.t < cutoff) continue;
            if (!matchesFilter(m.msg, ft, mode)) continue;
            const key = m.user.toLowerCase();
            if (!byUser.has(key))
              byUser.set(key, { user: m.user, msg: m.msg, t: m.t });
          }
        }
        const list = Array.from(byUser.values());
        registeredCountEl.textContent = list.length;
        return list;
      }

      // Internal: perform the actual update now, mark timestamps and manage timers
      function performRegisteredUpdate(initiator) {
        // actual work
        computeRegistered(false);
        updateStats();
        lastRegisteredUpdate = Date.now();

        // any update resets the background inactivity timer to 1s
        if (bgInactivityTimer) {
          clearTimeout(bgInactivityTimer);
          bgInactivityTimer = null;
        }
        // schedule the inactivity timer: when it fires, it will request a timer-initiated update
        bgInactivityTimer = setTimeout(() => {
          bgInactivityTimer = null;
          requestRenderRegistered('timer');
        }, BG_MS);

        // If this update was initiated from non-chat sources, cancel any pending chat throttle timer
        if (initiator !== 'chat' && throttleTimer) {
          clearTimeout(throttleTimer);
          throttleTimer = null;
        }
      }

      // Public entry: request an update. initiator can be 'external' (user/chat/etc) or 'timer'
      function requestRenderRegistered(initiator = 'external') {
        const now = Date.now();
        const elapsed = now - lastRegisteredUpdate;

        if (initiator === 'chat') {
          // Apply throttle only for chat-initiated updates
          if (elapsed >= THROTTLE_MS || lastRegisteredUpdate === 0) {
            performRegisteredUpdate(initiator);
          } else {
            // schedule a throttled update if not already scheduled
            if (!throttleTimer) {
              const delay = THROTTLE_MS - elapsed;
              throttleTimer = setTimeout(() => {
                throttleTimer = null;
                performRegisteredUpdate('chat');
              }, delay);
            }
          }
        } else {
          // Non-chat initiators update immediately and cancel any pending chat throttle
          if (throttleTimer) {
            clearTimeout(throttleTimer);
            throttleTimer = null;
          }
          performRegisteredUpdate(initiator);
        }
      }

      // backward-compatible wrapper used elsewhere in code
      function renderRegistered() {
        requestRenderRegistered('external');
      }

      function matchesFilter(text, pattern, mode) {
        if (!pattern) return true;
        try {
          if (mode === "exact") return text.trim() === pattern;
          if (mode === "contains")
            return text.toLowerCase().includes(pattern.toLowerCase());
          if (mode === "regex") {
            const re = new RegExp(pattern);
            return re.test(text);
          }
        } catch (e) {
          return false;
        }
      }

      // tmi.js connection
      connectBtn.addEventListener("click", () => {
        const ch = (channelInput.value || "").trim();
        if (!ch) {
          alert("Введите название канала");
          return;
        }
        if (client) {
          try {
            client.disconnect();
          } catch (e) {}
          client = null;
          connectedChannel = null;
        }
        statusEl.textContent = "connecting...";
        client = new tmi.Client({ channels: [ch] });
        client
          .connect()
          .then(() => {
            statusEl.textContent = "connected";
            connectedChannel = ch;
          })
          .catch((err) => {
            statusEl.textContent = "error";
            alert("Ошибка подключения: " + err);
          });
        client.on("message", (channel, tags, message, self) => {
          // tags.username or tags['display-name']
          const user = tags["display-name"] || tags.username || "unknown";
          pushMessage({ user, msg: message, t: Date.now() });
            // chat-initiated update (subject to chat-only throttle)
            requestRenderRegistered('chat');
          // update custom chat view immediately (chat messages only)
          try { renderCustomChat(); } catch(e){/* ignore */}
        });
      });

      // load settings and initial render
      loadSettings();
      renderRegistered();

      // utility: load any existing storage and update UI periodically
      updateStats();

      // small helper so user knows about hosting
      if (location.protocol === "file:") {
        const note = document.createElement("div");
        note.className = "footer-note";
        note.textContent =
          "Примечание: для корректной работы встроенного чата откройте файл через локальный сервер (например: python -m http.server) и используйте домен в поле parent.";
        document.querySelector(".right").appendChild(note);
      }
    </script>
  </body>
</html>
